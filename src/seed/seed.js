import dotenv from "dotenv";
dotenv.config();

import bcrypt from "bcryptjs";
import { connectMongo } from "../config/dbMongo.js";
import { connectPostgres, sequelize } from "../config/dbPostgres.js";
import { Organization } from "../models/sql/Organization.js";
import { User } from "../models/sql/User.js";
import { env } from "../config/env.js";
import { Document } from "../models/mongo/Document.js";
import { DocumentVersion } from "../models/mongo/DocumentVersion.js";

// Load models
import "../models/sql/index.js";

(async () => {
    try {
        console.log("Starting safe seed...");

        await connectMongo();
        await connectPostgres();

        // Note: We no longer run sequelize.sync here to avoid conflicts with
        // materialized views. For fresh DB setup with schema + seed data, use:
        // node scripts/drop-mv-run-seed-recreate.js
        console.log('Connected to databases. Proceeding with seeding...');
        console.log('(Schema must already exist. Use migrations or setup script if needed.)');


        // 1. Seed Superadmin
        const superEmail = env.superadminEmail;
        let superadmin = await User.findOne({ where: { email: superEmail } });

        if (!superadmin) {
            const passwordHash = await bcrypt.hash(env.defaultAdminPassword, 10);
            superadmin = await User.create({
                fullName: "Seed Superadmin",
                email: superEmail,
                passwordHash,
                role: "superadmin",
                orgId: null,
            });
            console.log("Superadmin created");
        } else {
            console.log("Superadmin exists â€” skipping");
        }

        // 2. Seed Organizations
        const orgSeedData = [
            { name: "University of Windsor", type: "university" },
            { name: "ABC Corporate", type: "company" },
            { name: "Panjab University", type: "university" },
            { name: "TechStart Inc", type: "company" },
            { name: "Healthcare Plus", type: "healthcare" },
            { name: "St. Mary's College", type: "university" },
            { name: "Global Enterprises Ltd", type: "company" },
            { name: "City General Hospital", type: "healthcare" },
            { name: "National Institute of Technology", type: "university" },
            { name: "FinTech Solutions", type: "company" },
            { name: "Regional Medical Center", type: "healthcare" },
            { name: "Oxford Business School", type: "university" },
            { name: "DataCore Systems", type: "company" },
            { name: "Metropolitan University", type: "university" },
            { name: "CloudNine Technologies", type: "company" },
        ];

        const orgRecords = [];

        for (const orgInfo of orgSeedData) {
            let org = await Organization.findOne({ where: { name: orgInfo.name } });

            if (!org) {
                org = await Organization.create({
                    name: orgInfo.name,
                    type: orgInfo.type,
                    // slug is auto-generated by hook
                });
                console.log(`Created organization: ${orgInfo.name}`);
            } else {
                console.log(`Organization exists: ${orgInfo.name}`);
            }

            orgRecords.push(org);
        }

        // 3. Seed Admins for each org
        for (const org of orgRecords) {
            const email = `${org.name.replaceAll(" ", "").toLowerCase()}@org.com`;

            let admin = await User.findOne({ where: { email } });
            if (!admin) {
                const passwordHash = await bcrypt.hash(env.defaultAdminPassword, 10);

                admin = await User.create({
                    fullName: `${org.name} Admin`,
                    email,
                    passwordHash,
                    role: "admin",
                    orgId: org.id,
                });

                console.log(`Created admin for: ${org.name}`);
            } else {
                console.log(`Admin exists for: ${org.name}`);
            }
        }

        // 4. Seed Regular Users (Verifiers) for each org
        for (const org of orgRecords) {
            const users = [
                { 
                    fullName: `${org.name} Verifier`, 
                    email: `verifier@${org.name.replaceAll(" ", "").toLowerCase()}.com` 
                },
                { 
                    fullName: `${org.name} Staff`, 
                    email: `staff@${org.name.replaceAll(" ", "").toLowerCase()}.com` 
                },
                { 
                    fullName: `${org.name} Officer`, 
                    email: `officer@${org.name.replaceAll(" ", "").toLowerCase()}.com` 
                },
                { 
                    fullName: `${org.name} Coordinator`, 
                    email: `coordinator@${org.name.replaceAll(" ", "").toLowerCase()}.com` 
                },
                { 
                    fullName: `${org.name} Supervisor`, 
                    email: `supervisor@${org.name.replaceAll(" ", "").toLowerCase()}.com` 
                },
            ];

            for (const userData of users) {
                let user = await User.findOne({ where: { email: userData.email } });
                if (!user) {
                    const passwordHash = await bcrypt.hash(env.defaultUserPassword, 10);

                    user = await User.create({
                        fullName: userData.fullName,
                        email: userData.email,
                        passwordHash,
                        role: "verifier",
                        orgId: org.id,
                    });

                    console.log(`Created user: ${userData.fullName}`);
                } else {
                    console.log(`User exists: ${userData.fullName}`);
                }
            }
        }

        // 5. Seed Sample Documents for all organizations
        const documentTypes = ["transcript", "certificate", "letter", "license", "diploma", "permit", "contract", "invoice", "other"];
        const workflowStatuses = ["APPROVED", "PENDING", "REVOKED"];
        
        for (const org of orgRecords) {
            const adminUser = await User.findOne({ where: { orgId: org.id, role: 'admin' } });
            const regularUsers = await User.findAll({ where: { orgId: org.id, role: 'verifier' } });
            
            if (adminUser && regularUsers.length > 0) {
                // Create 15-25 documents per organization
                const numDocs = Math.floor(Math.random() * 11) + 15;
                
                for (let i = 0; i < numDocs; i++) {
                    const timestamp = Date.now() - (i * 86400000); // Spread across days
                    const docId = `DOC_${timestamp}_${org.name.substring(0, 3).toUpperCase()}_${i}`;
                    const type = documentTypes[Math.floor(Math.random() * documentTypes.length)];
                    const status = workflowStatuses[Math.floor(Math.random() * workflowStatuses.length)];
                    const creatorUser = Math.random() > 0.5 ? adminUser : regularUsers[Math.floor(Math.random() * regularUsers.length)];
                    
                    const existingDoc = await Document.findOne({ docId });
                    if (!existingDoc) {
                        const textHash = "0x" + Math.random().toString(16).substring(2).padEnd(64, '0');
                        const imageHash = "0x" + Math.random().toString(16).substring(2).padEnd(64, '0');
                        const merkleRoot = "0x" + Math.random().toString(16).substring(2).padEnd(64, '0');
                        
                        const doc = await Document.create({
                            docId,
                            type,
                            ownerOrgId: org.id,
                            currentVersion: 1,
                            metadata: {
                                fileType: "pdf",
                                pageCount: Math.floor(Math.random() * 20) + 1,
                                sizeInKB: Math.floor(Math.random() * 2000) + 100,
                                mimeType: "application/pdf",
                                title: `${type.charAt(0).toUpperCase() + type.slice(1)} Document ${i + 1}`,
                                description: `Sample ${type} document for ${org.name}`,
                            },
                            versionHashChain: [merkleRoot],
                        });

                        // Create initial version
                        await DocumentVersion.create({
                            docId,
                            versionNumber: 1,
                            merkleRoot,
                            versionHash: merkleRoot,
                            prevVersionHash: null,
                            workflowStatus: status,
                            createdByUserId: creatorUser.id,
                            ownerOrgId: org.id,
                            hashParts: {
                                textHash,
                                imageHash,
                                signatureHash: Math.random() > 0.5 ? "0x" + Math.random().toString(16).substring(2).padEnd(64, '0') : null,
                                stampHash: Math.random() > 0.7 ? "0x" + Math.random().toString(16).substring(2).padEnd(64, '0') : null,
                            },
                            createdAt: new Date(timestamp),
                            updatedAt: new Date(timestamp),
                        });

                        // 30% chance of having multiple versions
                        if (Math.random() > 0.7) {
                            const numVersions = Math.floor(Math.random() * 3) + 2; // 2-4 versions
                            let prevHash = merkleRoot;
                            
                            for (let v = 2; v <= numVersions; v++) {
                                const versionTimestamp = timestamp + (v * 3600000); // Hours apart
                                const newMerkleRoot = "0x" + Math.random().toString(16).substring(2).padEnd(64, '0');
                                
                                await DocumentVersion.create({
                                    docId,
                                    versionNumber: v,
                                    merkleRoot: newMerkleRoot,
                                    versionHash: newMerkleRoot,
                                    prevVersionHash: prevHash,
                                    workflowStatus: workflowStatuses[Math.floor(Math.random() * workflowStatuses.length)],
                                    createdByUserId: creatorUser.id,
                                    ownerOrgId: org.id,
                                    hashParts: {
                                        textHash: "0x" + Math.random().toString(16).substring(2).padEnd(64, '0'),
                                        imageHash: "0x" + Math.random().toString(16).substring(2).padEnd(64, '0'),
                                    },
                                    createdAt: new Date(versionTimestamp),
                                    updatedAt: new Date(versionTimestamp),
                                });
                                
                                prevHash = newMerkleRoot;
                                
                                // Update document
                                await Document.findOneAndUpdate(
                                    { docId },
                                    { 
                                        currentVersion: v,
                                        $push: { versionHashChain: newMerkleRoot }
                                    }
                                );
                            }
                        }

                        console.log(`Created document: ${docId} for ${org.name}`);
                    }
                }
            }
        }

        console.log("Safe seeding completed.");
        console.log("\n Summary:");
        console.log(`Organizations: ${orgRecords.length}`);
        const totalUsers = await User.count();
        console.log(`Total Users: ${totalUsers}`);
        const totalDocs = await Document.countDocuments();
        console.log(`Documents: ${totalDocs}`);
        const totalVersions = await DocumentVersion.countDocuments();
        console.log(`Document Versions: ${totalVersions}`);
        
        // Status breakdown
        const approvedCount = await DocumentVersion.countDocuments({ workflowStatus: 'APPROVED' });
        const pendingCount = await DocumentVersion.countDocuments({ workflowStatus: 'PENDING' });
        const revokedCount = await DocumentVersion.countDocuments({ workflowStatus: 'REVOKED' });
        console.log(`\nWorkflow Status Distribution:`);
        console.log(`  Approved: ${approvedCount}`);
        console.log(`  Pending: ${pendingCount}`);
        console.log(`  Revoked: ${revokedCount}`);
        
        process.exit(0);
    } catch (err) {
        console.error("Seeder error:", err);
        process.exit(1);
    }
})();
